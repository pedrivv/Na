#include <imgui.h>
#include <imgui_internal.h>
#include <EspLines/Memory/Memory.hpp>
#include <EspLines/Math/Vector/Vector3.hpp>
#include <EspLines/Math/Vector/Vector2.hpp>
#include <src/Globals.hpp>
#include <EspLines/Offsets.hpp>
#include <EspLines/Math/WordToScreen.hpp>
#include <iostream>
#include "DownPlayer.hpp"

std::atomic<bool> downPlayerRunning{ false };
std::thread downPlayerThread;

bool IsInsideFOV_Down(int x, int y) {
    int fov = g_Globals.AimBot.Fov;
    int centerX = g_Globals.EspConfig.Width / 2;
    int centerY = g_Globals.EspConfig.Height / 2;
    return (x - centerX) * (x - centerX) + (y - centerY) * (y - centerY) <= fov * fov;
}

void DownPlayer::DownPlayerr::DownPlayer() {
    if (!g_Globals.Exploits.DownPlayer)
        return;

    if ((GetAsyncKeyState(g_Globals.Exploits.DownPlayerBind) & 0x8000) == 0)
        return;

    if (downPlayerRunning) return;
    downPlayerRunning = true;

    downPlayerThread = std::thread([] {
        while (downPlayerRunning) {
            if ((GetAsyncKeyState(g_Globals.Exploits.DownPlayerBind) & 0x8000) == 0) {
                std::this_thread::sleep_for(std::chrono::milliseconds(1));
                continue;
            }

            if (g_Globals.EspConfig.Width == -1 || g_Globals.EspConfig.Height == -1 || !g_Globals.EspConfig.Matrix) {
                std::this_thread::sleep_for(std::chrono::milliseconds(1));
                continue;
            }

            bool isFiring;
            uint32_t localPlayer = g_Globals.EspConfig.LocalPlayer;
            if (!localPlayer) return;

            if (!Mem.Read<bool>(localPlayer + Offsets::pomba, isFiring) || !isFiring) {
                std::this_thread::sleep_for(std::chrono::milliseconds(1));
                continue;
            }

            for (const auto& pair : g_Globals.EspConfig.Entities) {
                const Player& entity = pair.second;
                if (!entity.IsKnown || entity.IsDead || entity.IsKnocked) continue;

                Vector2 screenPos = W2S::WorldToScreen(
                    g_Globals.EspConfig.ViewMatrix,
                    entity.Head,
                    g_Globals.EspConfig.Width,
                    g_Globals.EspConfig.Height
                );

                if (screenPos.X < 1 || screenPos.Y < 1) continue;
                if (!IsInsideFOV_Down((int)screenPos.X, (int)screenPos.Y)) continue;

                uint32_t enemyRootBone, enemyTransform, enemyTransformObj, enemyMatrix;
                Vector3 enemyPosition;

                if (!Mem.ReadFast2<uint32_t>(entity.Address + Offsets::Bones::Root, &enemyRootBone)) continue;
                if (!Mem.ReadFast2<uint32_t>(enemyRootBone + 0x8, &enemyTransform)) continue;
                if (!Mem.ReadFast2<uint32_t>(enemyTransform + 0x8, &enemyTransformObj)) continue;
                if (!Mem.ReadFast2<uint32_t>(enemyTransformObj + 0x20, &enemyMatrix)) continue;
                if (!Mem.ReadFast2<Vector3>(enemyMatrix + 0x80, &enemyPosition)) continue;

                enemyPosition.Y -= 0.0600f;

                Mem.Write<Vector3>(enemyMatrix + 0x80, enemyPosition);
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }
        });
    downPlayerThread.detach();
}

void DownPlayer::DownPlayerr::StopDownPlayer() {
    downPlayerRunning = false;
    if (downPlayerThread.joinable()) {
        downPlayerThread.join();
    }
}
