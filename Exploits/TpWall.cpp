#include <thread>
#include <atomic>
#include <chrono>
#include <iostream>
#include "TpWall.hpp"
#include <EspLines/Memory/Memory.hpp>
#include <EspLines/Math/Vector/Vector3.hpp>
#include <EspLines/Offsets.hpp>
#include <src/Globals.hpp>

namespace TpWall {
    static std::atomic<bool> isRunning{ false };
    static std::thread worker;
    static float teleportDistance = 1.5f; // Distância do teleporte (ajustável)
    static int teleportDelay = 10; // Delay entre teleportes em ms

    // Calcula nova posição baseada na direção do jogador
    Vector3 CalculateNewPosition(const Vector3& currentPos, const Vector3& cameraForward) {
        return {
            currentPos.X + (cameraForward.X * teleportDistance),
            currentPos.Y + (cameraForward.Y * teleportDistance),
            currentPos.Z + (cameraForward.Z * teleportDistance)
        };
    }

    // Obtém a direção da câmera do jogador
    bool GetCameraForward(Vector3& forward) {
        uint32_t localPlayer = g_Globals.EspConfig.LocalPlayer;
        if (!localPlayer) return false;

        uint32_t cameraPtr = 0;
        if (!Mem.ReadFast2<uint32_t>(localPlayer + Offsets::FollowCamera, &cameraPtr) || !cameraPtr)
            return false;

        uint32_t camera = 0;
        if (!Mem.ReadFast2<uint32_t>(cameraPtr + Offsets::Camera, &camera) || !camera)
            return false;

        uint32_t cameraBase = 0;
        if (!Mem.ReadFast2<uint32_t>(camera + 0x8, &cameraBase) || !cameraBase)
            return false;

        Matrix4x4 viewMatrix;
        if (!Mem.ReadFast2<Matrix4x4>(cameraBase + Offsets::ViewMatrix, &viewMatrix))
            return false;

        forward = {
            -viewMatrix.m20, // Forward X
            -viewMatrix.m21, // Forward Y
            -viewMatrix.m22  // Forward Z
        };

        return true;
    }

    void Start() {
        if (isRunning) return;
        isRunning = true;

        worker = std::thread([] {
            while (isRunning) {
                try {
                    if (!g_Globals.Exploits.TpWall) {
                        std::this_thread::sleep_for(std::chrono::milliseconds(teleportDelay));
                        continue;
                    }

                    // Só ativa com a bind
                    if ((GetAsyncKeyState(g_Globals.Exploits.TpWallBind) & 0x8000) == 0) {
                        std::this_thread::sleep_for(std::chrono::milliseconds(teleportDelay));
                        continue;
                    }

                    uint32_t localPlayer = g_Globals.EspConfig.LocalPlayer;
                    if (!localPlayer) {
                        std::this_thread::sleep_for(std::chrono::milliseconds(teleportDelay));
                        continue;
                    }

                    // Obtém a direção da câmera
                    Vector3 cameraForward;
                    if (!GetCameraForward(cameraForward))
                        continue;

                    // Pega root bone pointer
                    uint32_t rootBonePtr = 0;
                    if (!Mem.ReadFast2<uint32_t>(localPlayer + Offsets::Bones::Root, &rootBonePtr) || !rootBonePtr)
                        continue;

                    uint32_t transform1 = 0;
                    if (!Mem.ReadFast2<uint32_t>(rootBonePtr + 0x8, &transform1) || !transform1)
                        continue;

                    uint32_t transform2 = 0;
                    if (!Mem.ReadFast2<uint32_t>(transform1 + 0x8, &transform2) || !transform2)
                        continue;

                    uint32_t matrixPtr = 0;
                    if (!Mem.ReadFast2<uint32_t>(transform2 + 0x20, &matrixPtr) || !matrixPtr)
                        continue;

                    // Posição atual
                    Vector3 currentPos;
                    if (!Mem.ReadFast2<Vector3>(matrixPtr + 0x80, &currentPos))
                        continue;

                    // Calcula nova posição na direção da câmera
                    Vector3 newPos = CalculateNewPosition(currentPos, cameraForward);

                    // Aplica o teleporte
                    Mem.Write<Vector3>(matrixPtr + 0x80, newPos);

                    // Pequeno delay para evitar teleportes muito rápidos
                    std::this_thread::sleep_for(std::chrono::milliseconds(teleportDelay));
                }
                catch (...) {
                    // Evita crash
                }
            }
            });
    }

    void Stop() {
        if (!isRunning) return;
        isRunning = false;

        if (worker.joinable())
            worker.join();
    }

    // Funções para configuração
    void SetTeleportDistance(float distance) {
        teleportDistance = distance;
    }

    void SetTeleportDelay(int delayMs) {
        teleportDelay = delayMs;
    }
}