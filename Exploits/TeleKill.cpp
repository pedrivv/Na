#include "TeleKill.hpp"
#include <EspLines/Memory/Memory.hpp>
#include <EspLines/Math/Vector/Vector3.hpp>
#include <EspLines/Math/Vector/Vector2.hpp>
#include <EspLines/Offsets.hpp>
#include <src/Globals.hpp>
#include <EspLines/Math/WordToScreen.hpp>
#include <imgui.h>
#include <cmath>
#include <limits>

namespace {
    // Função para escolher hitbox conforme config
    Vector3 GetHitBoxPosition(const Player& entity) {
        using HitBox = Config::HitBox;

        switch (g_Globals.Silent.HitBox) {
        case HitBox::Neck:  return entity.Neck;
        case HitBox::Chest: return entity.Hip;
        case HitBox::Head:  return entity.Head;
        default:            return entity.Head;
        }
    }

    // Procura inimigo mais próximo do centro da tela
    Player* FindClosestEnemy() {
        float closestDistance = FLT_MAX;
        Player* closestEntity = nullptr;

        Vector2 screenCenter(
            g_Globals.EspConfig.Width / 2.0f,
            g_Globals.EspConfig.Height / 2.0f
        );

        for (auto& pair : g_Globals.EspConfig.Entities) {
            Player* entity = &pair.second;
            if (entity->IsDead || (g_Globals.AimBot.IgnoreKnocked && entity->Pose == Offsets::XPose))
                continue;

            ImVec2 hitBox2D = W2S::WorldToScreenImVec2(
                g_Globals.EspConfig.ViewMatrix,
                entity->Head,
                g_Globals.EspConfig.Width,
                g_Globals.EspConfig.Height
            );
            if (hitBox2D.x < 1 || hitBox2D.y < 1) continue;

            float distance = Vector3::Distance(g_Globals.EspConfig.MainCamera, entity->Head);
            if (distance > g_Globals.AimBot.DistanceAim) continue;

            float crosshairDist = std::sqrt(
                std::pow(hitBox2D.x - screenCenter.X, 2) +
                std::pow(hitBox2D.y - screenCenter.Y, 2)
            );

            if (crosshairDist < closestDistance) {
                closestDistance = crosshairDist;
                closestEntity = entity;
            }
        }

        return closestEntity;
    }

    std::atomic<bool> isRunning{ false };
    std::thread worker;
}

namespace TeleKill {

    void Start() {
        if (isRunning) return;
        isRunning = true;

        worker = std::thread([] {
            while (isRunning) {
                try {
                    if (!g_Globals.Exploits.TeleKill) {
                        std::this_thread::sleep_for(std::chrono::milliseconds(1));
                        continue;
                    }

                    Player* target = FindClosestEnemy();
                    if (!target || target->Address == 0) {
                        std::this_thread::sleep_for(std::chrono::milliseconds(1));
                        continue;
                    }

                    uint32_t localPlayer = g_Globals.EspConfig.LocalPlayer;
                    if (!localPlayer) {
                        std::this_thread::sleep_for(std::chrono::milliseconds(1));
                        continue;
                    }

                    // pega posição do localPlayer
                    uint32_t localRoot = 0;
                    if (!Mem.ReadFast2<uint32_t>(localPlayer + Offsets::Bones::Root, &localRoot) || !localRoot)
                        continue;

                    uint32_t t1 = 0; Mem.ReadFast2(localRoot + 0x8, &t1);
                    uint32_t t2 = 0; Mem.ReadFast2(t1 + 0x8, &t2);
                    uint32_t localMatrix = 0; Mem.ReadFast2(t2 + 0x20, &localMatrix);

                    Vector3 localPos;
                    if (!Mem.ReadFast2<Vector3>(localMatrix + 0x80, &localPos))
                        continue;

                    // hitbox do alvo escolhido
                    Vector3 targetHitBox = GetHitBoxPosition(*target);

                    float dist = Vector3::Distance(localPos, targetHitBox);
                    if (dist > 10.0f) {
                        std::this_thread::sleep_for(std::chrono::milliseconds(1));
                        continue;
                    }

                    // pega root do inimigo
                    uint32_t enemyRoot = 0;
                    if (!Mem.ReadFast2<uint32_t>(target->Address + Offsets::Bones::Root, &enemyRoot) || !enemyRoot)
                        continue;

                    uint32_t et1 = 0; Mem.ReadFast2(enemyRoot + 0x8, &et1);
                    uint32_t et2 = 0; Mem.ReadFast2(et1 + 0x8, &et2);
                    uint32_t enemyMatrix = 0; Mem.ReadFast2(et2 + 0x20, &enemyMatrix);

                    // teleporta inimigo pro local do player
                    Mem.Write<Vector3>(enemyMatrix + 0x80, localPos);
                }
                catch (...) {
                    // evita crash
                }

                std::this_thread::sleep_for(std::chrono::milliseconds(1));
            }
            });
    }

    void Stop() {
        if (!isRunning) return;
        isRunning = false;

        if (worker.joinable())
            worker.join();
    }
}
