#include <imgui.h>
#include <imgui_internal.h>
#include <EspLines\Memory\Memory.hpp>
#include <EspLines\Math\Vector\Vector3.hpp>
#include <EspLines\Math\Vector\Vector2.hpp>
#include <src\Globals.hpp>
#include <EspLines\Offsets.hpp>
#include <EspLines\Math\WordToScreen.hpp>
#include <iostream>
#include "UpPlayer.hpp"

std::atomic<bool> upPlayerRunning{ false };
std::thread upPlayerThread;

bool IsInsideFOV(int x, int y) {
    int fov = g_Globals.AimBot.Fov;
    int centerX = g_Globals.EspConfig.Width / 2;
    int centerY = g_Globals.EspConfig.Height / 2;
    return (x - centerX) * (x - centerX) + (y - centerY) * (y - centerY) <= fov * fov;
}

void UpPlayer::UpPlayerr::UpPlayer() {
    if (!g_Globals.Exploits.UpPlayer)
        return;

    if ((GetAsyncKeyState(g_Globals.Exploits.UpPlayerBind) & 0x8000) == 0)
        return;

    if (upPlayerRunning) return;
    upPlayerRunning = true;

    upPlayerThread = std::thread([] {
        while (upPlayerRunning) {
            if ((GetAsyncKeyState(g_Globals.Exploits.UpPlayerBind) & 0x8000) == 0) {
                std::this_thread::sleep_for(std::chrono::milliseconds(1));
                continue;
            }

            if (g_Globals.EspConfig.Width == -1 || g_Globals.EspConfig.Height == -1 || !g_Globals.EspConfig.Matrix) {
                std::this_thread::sleep_for(std::chrono::milliseconds(1));
                continue;
            }

            bool isFiring;
            uint32_t localPlayer = g_Globals.EspConfig.LocalPlayer;
            if (!localPlayer) return;

            if (!Mem.Read<bool>(localPlayer + Offsets::pomba, isFiring) || !isFiring) {
                std::this_thread::sleep_for(std::chrono::milliseconds(1));
                continue;
            }

            for (const auto& pair : g_Globals.EspConfig.Entities) {
                const Player& entity = pair.second;
                if (!entity.IsKnown || entity.IsDead || entity.IsKnocked) continue;

                Vector2 screenPos = W2S::WorldToScreen(
                    g_Globals.EspConfig.ViewMatrix,
                    entity.Head,
                    g_Globals.EspConfig.Width,
                    g_Globals.EspConfig.Height
                );

                if (screenPos.X < 1 || screenPos.Y < 1) continue;
                if (!IsInsideFOV((int)screenPos.X, (int)screenPos.Y)) continue;

                uint32_t enemyRootBone, enemyTransform, enemyTransformObj, enemyMatrix;
                Vector3 enemyPosition;

                if (!Mem.ReadFast2<uint32_t>(entity.Address + Offsets::Bones::Root, &enemyRootBone)) {
                    std::cerr << "Failed to read enemyRootBone at address: " << std::hex << (entity.Address + Offsets::Bones::Root) << std::endl;
                    continue;
                }
                if (!Mem.ReadFast2<uint32_t>(enemyRootBone + 0x8, &enemyTransform)) {
                    std::cerr << "Failed to read enemyTransform at address: " << std::hex << (enemyRootBone + 0x8) << std::endl;
                    continue;
                }
                if (!Mem.ReadFast2<uint32_t>(enemyTransform + 0x8, &enemyTransformObj)) {
                    std::cerr << "Failed to read enemyTransformObj at address: " << std::hex << (enemyTransform + 0x8) << std::endl;
                    continue;
                }
                if (!Mem.ReadFast2<uint32_t>(enemyTransformObj + 0x20, &enemyMatrix)) {
                    std::cerr << "Failed to read enemyMatrix at address: " << std::hex << (enemyTransformObj + 0x20) << std::endl;
                    continue;
                }
                if (!Mem.ReadFast2<Vector3>(enemyMatrix + 0x80, &enemyPosition)) {
                    std::cerr << "Failed to read enemyPosition at address: " << std::hex << (enemyMatrix + 0x80) << std::endl;
                    continue;
                }

                enemyPosition.Y += 0.0600f;
                Mem.Write<Vector3>(enemyMatrix + 0x80, enemyPosition);
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }
        });
    upPlayerThread.detach();
}

void UpPlayer::UpPlayerr::StopUpPlayer() {
    upPlayerRunning = false;
    if (upPlayerThread.joinable()) {
        upPlayerThread.join();
    }
}